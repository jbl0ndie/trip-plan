// Export functionality for calendar integration

class ExportManager {
    // Generate ICS (iCalendar) format for calendar import
    static generateICS(itinerary, tripStartDate, tripEndDate) {
        if (!itinerary || !itinerary.locations || itinerary.locations.length === 0) {
            throw new Error('Invalid itinerary data for export');
        }

        if (!tripStartDate) {
            throw new Error('Trip start date is required for export');
        }

        const startDate = new Date(tripStartDate);
        let icsContent = [
            'BEGIN:VCALENDAR',
            'VERSION:2.0',
            'PRODID:-//Trip Planner//Trip Planner//EN',
            'CALSCALE:GREGORIAN',
            'METHOD:PUBLISH',
            'X-WR-CALNAME:' + itinerary.name,
            'X-WR-CALDESC:Trip itinerary generated by Trip Planner'
        ];

        let currentDate = new Date(startDate);

        itinerary.locations.forEach((location, index) => {
            if (!location.name || !location.name.trim()) return;

            // Create event for each night at the location
            for (let night = 0; night < location.nights; night++) {
                const eventDate = new Date(currentDate);
                eventDate.setDate(currentDate.getDate() + night);
                
                const nextDay = new Date(eventDate);
                nextDay.setDate(eventDate.getDate() + 1);
                
                const dateStr = this.formatICSDate(eventDate);
                const endDateStr = this.formatICSDate(nextDay);
                
                const eventId = `trip-${itinerary.id}-location-${index}-night-${night}@tripplanner.com`;
                
                let summary = location.name;
                if (location.nights > 1) {
                    summary += ` (Night ${night + 1}/${location.nights})`;
                }

                let description = `${itinerary.name} - Day ${location.day}`;
                if (night === 0 && location.drivingTime > 0) {
                    description += `\\nDriving time: ${Utils.formatDriveTime(location.drivingTime)}`;
                }
                if (location.notes) {
                    description += `\\nNotes: ${location.notes}`;
                }

                icsContent.push(
                    'BEGIN:VEVENT',
                    `UID:${eventId}`,
                    `DTSTART;VALUE=DATE:${dateStr}`,
                    `DTEND;VALUE=DATE:${endDateStr}`,
                    `SUMMARY:${summary}`,
                    `DESCRIPTION:${description}`,
                    `LOCATION:${location.name}`,
                    `DTSTAMP:${this.formatICSDateTime(new Date())}`,
                    'TRANSP:TRANSPARENT',
                    'STATUS:CONFIRMED',
                    'END:VEVENT'
                );
            }

            // Add driving time to next location (except for last location)
            if (index < itinerary.locations.length - 1 && location.drivingTime > 0) {
                currentDate.setDate(currentDate.getDate() + location.nights);
                
                const driveDate = new Date(currentDate);
                const driveEndDate = new Date(currentDate.getTime() + location.drivingTime * 60 * 1000);
                
                const driveEventId = `trip-${itinerary.id}-drive-${index}@tripplanner.com`;
                
                icsContent.push(
                    'BEGIN:VEVENT',
                    `UID:${driveEventId}`,
                    `DTSTART:${this.formatICSDateTime(driveDate)}`,
                    `DTEND:${this.formatICSDateTime(driveEndDate)}`,
                    `SUMMARY:Drive to ${itinerary.locations[index + 1]?.name || 'Next Location'}`,
                    `DESCRIPTION:${itinerary.name} - Travel time: ${Utils.formatDriveTime(location.drivingTime)}`,
                    `LOCATION:${location.name} to ${itinerary.locations[index + 1]?.name || 'Next Location'}`,
                    `DTSTAMP:${this.formatICSDateTime(new Date())}`,
                    'TRANSP:OPAQUE',
                    'STATUS:CONFIRMED',
                    'CATEGORIES:TRAVEL',
                    'END:VEVENT'
                );
            } else {
                currentDate.setDate(currentDate.getDate() + location.nights);
            }
        });

        icsContent.push('END:VCALENDAR');
        
        return icsContent.join('\\r\\n');
    }

    // Export itinerary as ICS file
    static exportToICS(itinerary, tripStartDate, tripEndDate) {
        try {
            const icsContent = this.generateICS(itinerary, tripStartDate, tripEndDate);
            
            const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
            const link = document.createElement('a');
            
            link.href = URL.createObjectURL(blob);
            link.download = `${this.sanitizeFilename(itinerary.name)}-itinerary.ics`;
            
            // Trigger download
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            URL.revokeObjectURL(link.href);
            
            Utils.showToast('Calendar file exported successfully', 'success');
            return true;
        } catch (error) {
            console.error('Export failed:', error);
            Utils.showToast('Export failed: ' + error.message, 'error');
            return false;
        }
    }

    // Export itinerary as JSON
    static exportToJSON(itinerary) {
        try {
            const data = {
                exportDate: new Date().toISOString(),
                version: '1.0.0',
                itinerary: itinerary.toJSON()
            };
            
            const jsonStr = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const link = document.createElement('a');
            
            link.href = URL.createObjectURL(blob);
            link.download = `${this.sanitizeFilename(itinerary.name)}-itinerary.json`;
            
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            URL.revokeObjectURL(link.href);
            
            Utils.showToast('JSON file exported successfully', 'success');
            return true;
        } catch (error) {
            console.error('JSON export failed:', error);
            Utils.showToast('JSON export failed: ' + error.message, 'error');
            return false;
        }
    }

    // Generate shareable text summary
    static generateTextSummary(itinerary, tripStartDate, tripEndDate) {
        let summary = [`${itinerary.name}`, '='.repeat(itinerary.name.length), ''];

        if (tripStartDate && tripEndDate) {
            summary.push(`Trip Dates: ${Utils.formatDate(tripStartDate)} - ${Utils.formatDate(tripEndDate)}`);
            summary.push('');
        }

        summary.push(`Total Locations: ${itinerary.locations.length}`);
        summary.push(`Total Nights: ${itinerary.getTotalNights()}`);
        summary.push(`Total Drive Time: ${Utils.formatDriveTime(itinerary.getTotalDriveTime())}`);
        summary.push('');

        summary.push('ITINERARY:');
        summary.push('-'.repeat(10));

        itinerary.locations.forEach((location, index) => {
            summary.push(`${index + 1}. ${location.name} (${location.nights} night${location.nights !== 1 ? 's' : ''})`);
            
            if (location.drivingTime > 0 && index < itinerary.locations.length - 1) {
                summary.push(`   â†’ Drive to next: ${Utils.formatDriveTime(location.drivingTime)}`);
            }
            
            if (location.notes) {
                summary.push(`   Notes: ${location.notes}`);
            }
            
            summary.push('');
        });

        summary.push('Generated by Trip Planner');
        
        return summary.join('\\n');
    }

    // Copy itinerary summary to clipboard
    static async copyToClipboard(itinerary, tripStartDate, tripEndDate) {
        try {
            const textSummary = this.generateTextSummary(itinerary, tripStartDate, tripEndDate);
            
            if (navigator.clipboard && window.isSecureContext) {
                await navigator.clipboard.writeText(textSummary);
            } else {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = textSummary;
                textArea.style.position = 'fixed';
                textArea.style.opacity = '0';
                
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
            }
            
            Utils.showToast('Itinerary copied to clipboard', 'success');
            return true;
        } catch (error) {
            console.error('Copy to clipboard failed:', error);
            Utils.showToast('Failed to copy to clipboard', 'error');
            return false;
        }
    }

    // Helper method to format ICS date (YYYYMMDD)
    static formatICSDate(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}${month}${day}`;
    }

    // Helper method to format ICS datetime (YYYYMMDDTHHMMSSZ)
    static formatICSDateTime(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getUTCHours()).padStart(2, '0');
        const minutes = String(date.getUTCMinutes()).padStart(2, '0');
        const seconds = String(date.getUTCSeconds()).padStart(2, '0');
        return `${year}${month}${day}T${hours}${minutes}${seconds}Z`;
    }

    // Helper method to sanitize filename
    static sanitizeFilename(filename) {
        return filename
            .replace(/[^a-z0-9\-_]/gi, '_')
            .replace(/_+/g, '_')
            .replace(/^_|_$/g, '')
            .toLowerCase() || 'itinerary';
    }

    // Get available export formats
    static getExportFormats() {
        return [
            {
                id: 'ics',
                name: 'Calendar (ICS)',
                description: 'Import into Google Calendar, Apple Calendar, or Outlook',
                extension: '.ics',
                mimeType: 'text/calendar'
            },
            {
                id: 'json',
                name: 'JSON',
                description: 'Machine-readable format for backup or sharing',
                extension: '.json',
                mimeType: 'application/json'
            },
            {
                id: 'text',
                name: 'Text Summary',
                description: 'Copy to clipboard for sharing in messages',
                extension: '.txt',
                mimeType: 'text/plain'
            }
        ];
    }
}
